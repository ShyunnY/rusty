## Rust多线程编发编程

### 使用多线程

#### 总结

Rust 的线程模型是 `1:1` 模型, 因为 Rust 要**保持尽量小的运行时**

我们可以使用 `thread::spawn` 来创建线程, 创建出的**多个线程之间并不存在执行顺序关系**, 因此代码逻辑千万不要依赖于线程间的执行顺序。

**`main` 线程若是结束, 则所有子线程都将被终止**

如果希望等待子线程结束后, 再结束 main 线程，你需要使用创建线程时返回的句柄的 `join` 方法(join 方法将会阻塞等待子线程执行结束)

**在线程中无法直接借用外部环境中的变量值**, 因为新线程的启动时间点和结束时间点是不确定的
所以 Rust **无法保证该线程中借用的变量在使用过程中依然是合法的**

你可以使用 `move` 关键字将变量的所有权转移给新的线程, 来解决此问题(或者我们会使用 `Arc` 在不同的线程中共享变量)

子线程何时结束, 存在以下两点:
* 父线程不是 `main` : 子线程会执行完代码后才结束
* 父线程是 `main` : 如果子线程还没执行完, `main` 线程就结束了, 那么子线程也不会继续执行而是直接结束

一句话概括: **父线程结束后子线程仍在持续运行, 直到子线程的代码运行完成或者 main 线程的结束**

