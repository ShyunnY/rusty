#[allow(dead_code)]
pub fn hello() {
    // Drop 释放资源
    // 在Rust中, 我们之所以可以一拳打跑 GC 的同时一脚踢翻手动资源回收
    // 主要就归功于 Drop 特征, 同时它也是智能指针的必备特征之一

    // (1) Rust 中的资源回收
    /*
       在一些 无GC 语言中, 程序员在一个变量无需再被使用时, 需要手动释放它占用的内存资源
       如果忘记了, 那么就会发生内存泄漏, 最终臭名昭著的 OOM 问题可能就会发生(Clang......)

       而在Rust中, 你可以 "指定在一个**变量**超出作用域时, 执行一段特定的代码" 最终编译器将帮你自动插入这段收尾代码
       这样就无需在每一个使用该变量的地方, 都写一段代码来进行"收尾工作和资源释放"
       没错, 指定这样一段收尾工作靠的就是咱这章的主角 - "Drop trait"
    */

    // 一个例子
    {
        struct Foo;

        impl Drop for Foo {
            fn drop(&mut self) {
                println!("foo被清理了")
            }
        }

        struct Bar;

        impl Drop for Bar {
            fn drop(&mut self) {
                println!("bar被清理了")
            }
        }

        struct Quz {
            foo: Foo,
            bar: Bar,
        }

        impl Drop for Quz {
            fn drop(&mut self) {
                println!("quz被清理了")
            }
        }

        let _quz = Quz { foo: Foo, bar: Bar };
        let _foo = Foo;

        // 这里有几个点需要注意:
        // 1.Drop 特征中的`drop`方法借用了目标的"可变引用", 而不是拿走了所有权
        //   drop之所以是&mut self, 是为了在清理时可以方便的修改实例内部的信息
        // 2.结构体中"每个字段都有自己的 Drop"
    }
    // 1. Drop 的顺序
    /*
    观察以下输出, 我们可以得出以下关于 Drop 顺序的结论
    ```
    foo被清理了 // _foo调用drop（定义逆序）
    quz被清理了 // _quz调用drop（定义逆序）
    foo被清理了 // _quz.foo 调用drop （字段顺序）
    bar被清理了 // _quz.bar 调用drop （字段顺序）
    ```
    1.变量级别, 按照 "逆序" 的方式, _quz 在 _foo 之前创建, 因此 _quz 在 _foo 之后被 drop
    2.结构体内部, 按照 "顺序" 的方式, 结构体 _quz 中的字段"按照定义中的顺序依次 drop"
    */
    //
    // 2. 没有实现 Drop 的结构体
    // 实际上, 就算你不为 _quz 结构体实现 Drop 特征, 它内部的两个字段依然会调用 drop
    // 原因在于: Rust "自动为几乎所有类型都实现了 Drop 特征"
    // 因此就算你不手动为结构体实现 Drop, 它依然会调用"默认实现的 drop 函数", 同时再调用"每个字段的 drop 方法"

    // (2) 手动回收
    /*
       当使用智能指针来管理锁的时候, 你可能希望提前释放这个锁, 然后让其它代码能及时获得锁. 此时就需要提前去手动 drop
       但是在之前我们提到一个悬念, Drop::drop 只是"借用了目标值的可变引用"
       所以, 就算你提前调用了 drop, 后面的代码"依然可以使用目标值"
       但是这就会访问一个并不存在的值, 非常不安全! 好在 Rust 会阻止你
    */
    {
        // example
        struct Foo;

        impl Drop for Foo {
            fn drop(&mut self) {
                println!("提前释放Foo");
            }
        }

        let mut _f = Foo;
        // f.drop();    // 编译器直接阻止了我们调用 Drop 特征的 drop 方法

        // 原因是对于 Rust 而言, 不允许显式地调用析构函数（这是一个用来清理实例的通用编程概念）
        // drop方法不给我们调用, 但是我们可以调用 drop 函数!
        drop(_f);

        /*
           我们可以看一下 std::mem::drop 的源码:
           pub fn drop<T>(_x: T) {}

           实际上这个函数完美拿走了所有权, 什么都不干.
           我们知道: 当所有权超出作用域后将会自动Drop, 实际上他就是将所有权move到函数内, 再让其超出作用域自动Drop
        */
    }

    // (3) Drop的使用场景
    /*
       对于 Drop 而言, 主要有两个功能:
       1.回收内存资源
       2.执行一些收尾工作

       在绝大多数情况下, 我们都无需手动去 drop 以来回收内存资源
       因为Rust会自动帮我们完成这些工作, 它甚至会对复杂类型的每个字段都单独的调用 drop 进行回收！
       但是确实有极少数情况, 需要我们自己来回收资源的。"例如文件描述符、网络 socket 等"
       当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，
       在这些情况下， 就需要使用者自己来解决 Drop 的问题
    */

    // (4) 互斥的 Copy 和 Drop
    // "我们无法为一个类型同时实现 Copy 和 Drop 特征"
    // 因为实现了 Copy 的特征会被"编译器隐式的复制", 因此非常难以预测析构函数执行的时间和频率。
    // **"因此这些实现了 Copy 的类型无法拥有析构函数"**
    /*
       更重要的是内存安全（资源正确释放）方面的考虑
       copy可以理解为栈内存的简单复制, 通常意义上的浅拷贝 (trivial copy)

        简单举例来说, 有一个结构体只包含一个指针, 这个指针指向"分配出来的堆内存"
        它实现了Drop, 作用是释放堆上的内存（类似于c++里面的析构函数）
        编译器做的工作是在栈上分配的类或者结构体, 在离开作用域时自动插入析构的函数

        copy"会把这个指针复制一遍", 这时候就有两个结构体在栈上
        结构体离开了作用域, 会调用drop! 这个时候就会调用两遍析构
        但是结构体管理的实际资源（堆上的一段内存）"只有一个", 此时资源就被"释放两遍了", 这是一种内存错误

        解决方法就是:
        1. 不仅仅复制栈上的结构, 我复制这个结构体的时候把资源也复制一份, 也就是: "clone trait"(克隆, 深拷贝)
        2. 使用智能指针, 给资源做一个引用计数. 结构体作为引用计数和资源的控制结构。
           每次出作用域的时候，就检查一遍引用计数，判断此时可以不可以释放。
        3. 禁止复制, 也就是move语义. 资源的控制结构只存在一个, 这个"控制结构拥有所有权"
           move语义的赋值其实也是仅仅复制栈上的结构, 但是编译器帮我记住现有栈上有效的结构到底是哪一个
        4. 有gc的，就用gc来释放

        copy是允许浅拷贝的标记
        rust不允许这种用到堆内存又允许浅拷贝的危险结构存在, 所以 Copy 和 Drop 在rust中是互斥的!!!
    */

    // 一个小总结
    /*
       Drop 可以用于许多方面, "来使得资源清理及收尾工作变得方便和安全", 甚至可以用其创建我们自己的内存分配器！
       通过Drop特征和Rust所有权系统, 你无需担心之后的代码清理, Rust 会自动考虑这些问题。

       我们也无需担心意外的清理掉仍在使用的值, 这会造成编译器错误："所有权系统确保引用总是有效的"
       也会确保 drop 只会"在值不再被使用时被调用一次"

       rust通过 Drop 进行了半自动的GC来减少内存使用

       同时: 即使在函数/线程中发生了panic, 按照栈的逆序执行(从栈顶到栈底)
    */
}
