use std::fmt::Debug;

#[allow(dead_code)]
pub fn hello() {
    // Size和不定长的DST(dynamic size type)
    /*
        如果从编译器何时能获知"类型大小"的角度出发, 可以分成两类:
        1. 定长类型(sized)，这些类型的大小在"编译时是已知的"
        2/ 不定长类型(unsized)，与定长类型相反, 它的大小"只有到了程序运行时才能动态获知", 这种类型又被称之为 DST
    */

    // (1) 动态大小类型 DST
    // DST: 编译器无法在编译期得知该类型值的大小, 只有到了程序运行时(runtime), 才能动态获知
    // 对于动态类型, 我们使用 DST(dynamically sized types)或者 unsized 类型来称呼它
    // 类似 vec,set,hashmap 这些集合虽然底层数据可动态变化, 感觉像是动态大小的类型
    // 但是实际上, 这些"底层数据只是保存在堆上", 在栈中还存有一个"引用类型"
    // 该引用包含了集合的内存地址、元素数目、分配空间信息, 通过这些信息, 编译器对于该集合的实际大小了若指掌
    // 最最最重要的是: "栈上的引用类型是固定大小的", 因此它们依然是固定大小的类型
    // 换句话说: 在栈上rust编译器可以判断出其引用大小是具有固定大小的, 所以是可以通过编译的
    // > 正因为编译器无法在编译期获知类型大小, 若你试图在代码中直接使用 DST 类型, 将无法通过编译
    //
    // 那么我们在编写代码时, 总会遇到需要将动态数据固定大小化, 我们应该如何做?
    // 答案是: 将动态数据固定化的秘诀就是"使用引用指向这些动态数据", 然后在引用中存储相关的内存位置、长度等信息
    {
        // 例如我们使用特征对象时, 特征对象只有在runtime时才知道其真实类型, 所以我们需要使用其引用
        trait Example {}

        // 通过引用的方式使用特征对象
        fn demo1(_t: &dyn Example) {} // Ok

        // 通过智能指针Box 引用使用特征对象
        fn demo2(_t: Box<dyn Example>) {} // Ok

        // fn demo2(t: dyn Example>) {} // error
    }
    // 总结: 只能间接使用的 DST, 无法直接使用DST, 因为其不具有固定大小

    // (2) Sized特征
    /*
       既然动态类型的问题这么大, 那么在使用泛型时, Rust 如何保证我们的泛型参数是固定大小的类型呢？
       例如以下泛型函数:
       fn generic<T>(t: T){}

       rust那么如何保证我们传递的realType T 是固定大小的类型？

       奥秘在于编译器自动帮我们加上了 Sized 特征约束:
       fn generic<T: Sized>(t: T){}
    */
    // Rust 自动添加的特征约束 `T: Sized``, 表示泛型函数只能用于一切实现了 Sized 特征的类型上
    // 而所有在编译时就能知道其大小的类型, 都会自动实现 Sized 特征
    // 几乎能想得到的类型都实现了该特征, 除了trait。。。
    // "每一个特征都是一个可以通过名称来引用的动态大小类型". 因此如果想把特征作为具体的类型来传递给函数
    // 你必须将其"转换成一个特征对象": 诸如 &dyn Trait 或者 Box<dyn Trait> (还有 Rc<dyn Trait>)这些引用类型
    // 换句话说: 如果我们想使用特征对象, 就需要对其使用引用类型（本质上就是为了将动态大小固定化~）

    // (3) ?Sized特征
    // 现在还有一个问题: 假如想在泛型函数中使用动态数据类型怎么办？
    // 可以使用 ?Sized 特征(不得不说这个命名方式很 Rusty，竟然有点幽默)
    // ?Sized 特征用于表明类型 T 既有可能是固定大小的类型, 也可能是动态大小的类型
    {
        // Example
        fn demo1<T: Sized + Debug>(t: T) {
            println!("t: {:?}", t);
        }

        // 函数参数类型从 T 变成了 &T, 因为 T 可能是动态大小的, 因此需要用一个固定大小的指针(引用)来包裹它
        // 实际上我们在栈内还是需要使用固定大小数据, 所以我们依旧是需要使用引用
        fn demo2<T: ?Sized + Debug>(t: &T) {
            println!("t: {:?}", t);
        }

        let x = "hello, size";
        let y = 100;
        demo1(x);
        demo2(x);
        demo1(y);
        demo2(&y);
    }
}
