#[allow(dead_code)]
pub fn hello() {
    /*
    在一些场景, 我们可能"需要全局变量来简化状态共享的代码": 包括全局 ID,全局数据存储等等
    首先有一点可以肯定, "全局变量的生命周期肯定是'static", 但是不代表它需要用static来声明
    例如常量、字符串字面值等无需使用static进行声明, 原因是它们已经"被打包到二进制可执行文件中"(与程序共存亡)

    程序变量存在 "编译期初始化" 及 "运行期初始化"
    */

    // (1) 编译期初始化
    // 我们大多数使用的全局变量都只需要在编译期初始化即可, 例如静态配置、计数器、状态值等等
    //
    // 1.静态常量
    // "全局常量可以在程序任何一部分使用",  如果它是定义在某个模块中, 你需要引入对应的模块才能使用
    // 常量: 顾名思义它"是不可变的", 很适合用作静态配置
    // 我们需要注意以下几点不同
    /*
        常量与普通变量的区别:
        1.关键字是 "const" 而不是let
        2.定义常量 "必须指明类型"（如 i32）不能省略
        3.定义常量时变量的命名规则"一般是全部大写"
        4.常量可以在任意作用域进行定义, 其"生命周期贯穿整个程序的生命周期"
          编译时编译器会尽可能将其"内联到代码中", 所以 **"在不同地方对同一常量的引用并不能保证引用到相同的内存地址"**
        5.常量的赋值只能是"常量表达式/数学表达式", 也就是说"必须是在编译期就能计算出的值"!
          如果需要在运行时才能得出结果的值比如函数, 则不能赋值给常量表达式(常量就是编译期可以确定下来的值)
        6.对于变量出现"重复的定义(绑定)会发生变量遮盖", 后面定义的变量会遮住前面定义的变量, "常量则不允许出现重复的定义"(无法重复定义)
    */
    {
        const MAX_ID: usize = usize::MAX / 2;
        println!("1.1 最大ID值为: {}", MAX_ID);

        // 常量是不能调用函数的, 以下代码将会报错
        // fn dd() -> i32 {
        //     1
        // }
        // const VAL: i32 = dd();
    }
}
