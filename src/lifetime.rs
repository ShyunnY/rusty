pub fn _entry() {
    println!("hello, rust lifetime");

    // 认识生命周期
    // 生命周期: **简而言之就是引用的有效作用域**. 在大多数时候, 我们无需手动的声明生命周期, 因为编译器可以自动进行推导
    // 用类型来类比下:
    // 1). 就像编译器大部分时候可以自动推导类型 <_> 一样, 编译器大多数时候也可以自动推导生命周期
    // 2). 在多种类型存在时, 编译器往往要求我们手动标明类型 <_>.
    // 3). 当多个生命周期存在,且编译器无法推导出某个引用的生命周期时, 就需要我们"手动标明生命周期"
    //
    // 存在即合理, 那么生命周期的存在又是为了解决什么问题?
    // 1). 防止悬垂引用: 悬垂引用是指引用指向的内存**已经被释放**, 但引用本身仍然存在的情况.
    //     在 Rust 中, 编译器"通过生命周期确保引用不会超出它所引用的数据的生命周期"
    // 2). 明确引用的生命周期: 在某些复杂的情况下, Rust 编译器可能无法自动推断出引用的正确生命周期,
    //     这时需要程序员"显式地指定生命周期". 生命周期注解帮助编译器理解不同引用之间的关系, **确保所有引用在使用时都是有效的**
    //
    // 本质: 其根本其实是讨论 "被借用者和借用者之间的存活时间关系--即被借用者的存活时间必须大于等于借用者, 否则借用者会存在访问非法数据的可能."
    //
    // 这时就回到了开头说的内容: 在存在多个引用时, 编译器有时会无法自动推导生命周期, 此时就需要我们手动去标注
    // 通过 "为参数标注合适的生命周期" 来帮助 -> "编译器进行借用检查的分析"

    // (1) 悬挂指针和生命周期的那点事
    // 生命周期的主要作用是避免悬垂引用, 它会导致程序引用了本不该引用的数据
    // 例如:
    // 在这里point拥有更大的作用域, 或者说活得更久.
    // 如果Rust不阻止该悬垂引用的发生, 那么当 _x 被释放后, point 所引用的值就不再是合法的
    // 如果我们想解决也很简单: 让_x的生命周期大于等于point即可
    let point: &i32 = &1;
    {
        let _x = 5;
        // point = &_x  // point在这里借用了 _x 变量
    } // _x的生命周期到此为止了, 被Drop了.
    println!("point: {:?}", point); // 此时point就是个悬挂指针, 因为他借用的数据已经被清理了

    // (2) 借用检查
    // 为了保证 Rust 的所有权和借用的正确性, Rust 使用了一个借用检查器(Borrow checker), 来检查我们程序的借用正确性
    // 在编译期, Rust 会比较两个变量的生命周期. 结果发现 r 明明拥有生命周期 'a, 但是却引用了一个"小得多"的生命周期 'b
    // 在这种情况下编译器会认为我们的程序存在风险, 因此拒绝运行
    // 如果想要编译通过, 也很简单. 只要 'b 比 'a 大就好. 总之, x 变量只要比 r 活得久, 那么 r 就能随意引用 x 且不会存在危险
    // 一句话概括: 被借用者生命周期大于借用者即可~

    // (3) 函数中的生命周期
    // 假设我们在函数中, 定义其引用类型返回由参数提供, 并且存在多个参数. 此时rust就很迷茫了, 它并不知道引用是取决于哪个引用类型参数
    // 所以无法对此进行生命周期分析(毕竟也不知道是谁的引用). 此时就需要我们进行手动标注生命周期.

    // (4) 生命周期标注语法(生命周期标注并"不会改变任何引用的实际作用域" -- 鲁迅)
    //
    // 一个小总结: 生命周期语法用来将"函数的多个引用参数和返回值的作用域关联到一起(让返回值的生命周期等于所有参数生命周期较小的那一个)"
    // 一旦关联到一起后, Rust 就拥有充分的信息来确保我们的操作是内存安全的
    _lifetime_tag();

    // (5) 结构体中的生命周期
    // 设想一下: 当我们在结构体中将字段的类型设置为引用类型, 那么肯定是引用外部类型对吧?
    // 如果此时外部类型被销毁了呢, 结构体中的引用是不是就变成非法的了?
    // 所以我们需要为结构体中的"每一个引用类型的字段标注上生命周期"
    _lifetime_struct();
}

// 该生命周期标注说明, 结构体 Msg 所引用的字符串 str "必须大于等于结构体的寿命!!!"
#[derive(Debug)]
struct Msg<'a> {
    message: &'a str, // 如果不对其进行生命周期标注, 那么rust无法得知此引用是否会变的非法
}

fn _lifetime_struct() {
    // 此时我们可以正常编译, 因为我们确定 str 的生命周期跟 Msg 实例一样
    let str = String::from("hello,lifetime");
    let msg: Msg<'_> = Msg { message: &str };
    println!("msg: {:#?}", msg.message)
}

fn _lifetime_tag() {
    // 名言警句: 标记的生命周期只是为了取悦编译器, 让编译器不要难为我们, 记住了吗？
    // 通过生命周期标注其实就是告诉rust编译期: 别自作聪明了, 听我的就好

    // 1. 语法
    // &i32        // 一个引用
    // &'a i32     // 具有显式生命周期的引用
    // &'a mut i32 // 具有显式生命周期的可变引用
    // 例如: fn useless<'a>(first: &'a i32, second: &'a i32) {}
    // 此处生命周期标注仅仅说明, 这两个参数 first 和 second 至少活得和'a 一样久, 至于到底活多久或者哪个活得更久, 抱歉我们都无法得知
    // 我们只是为了取悦rust, 告诉它罢了
    //
    // 在通过函数签名指定生命周期参数时, 我们并没有改变传入引用或者返回引用的真实生命周期.
    // 而是告诉编译器当不满足此约束条件时, 就拒绝编译通过
    //
    // 生命周期永远只会取"最小"的那个生命周期

    // 举个栗子
    let s1 = String::from("0101");
    let result;
    {
        let s2 = String::from("01010");
        result = _logest_str(&s1, &s2);
        println!("result: {result}"); // 这里可以使用result, 因为其生命周期跟s2一样
    }
    // println!("result: {result}");    // 在此处无法使用result, 因为其生命周期是_logest_str参数中较小的那一个: 也就是s2

    // 2. 深入思考生命周期标注
    // 其实我们回想一下,函数的返回值如果是一个引用类型,那么它的生命周期只会来源于:
    // * 函数参数的生命周期(函数参数)
    // * 函数体中某个新建引用的生命周期(函数栈内变量, 此时就是典型的悬挂指针场景)
}

// 此处的返回值来自于参数, 所以rust编译期需要知道返回值的生命周期是多长
// 该函数签名表明对于某些生命周期 'a: 函数的两个参数都至少跟 'a 活得一样久, 同时函数的返回引用也至少跟 'a 活得一样久
// 实际上这意味着返回值的生命周期与参数生命周期中的"较小值一致", 虽然两个参数的生命周期都是标注了 'a
// 但是实际上这两个参数的真实生命周期可能是不一样的(生命周期 'a 不代表生命周期等于 'a，而是大于等于 'a)
fn _logest_str<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
