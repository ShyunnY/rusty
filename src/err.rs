pub fn _entry() {
    // err在什么语言中都是很重要的, 我们需要对此进行处理
    //
    // Rust 中的错误主要分为两类：
    // * 可恢复错误: 通常用于从系统全局角度来看可以接受的错误,例如处理用户的访问、操作等错误,
    //   这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响
    // * 不可恢复错误:刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，
    //   这些错误的影响往往对于系统来说是致命的
    // Rust没有异常, 但是 Rust 也有自己的卧龙凤雏: Result<T, E> "用于可恢复错误", panic! "用于不可恢复错误"
    _panic();
}

fn _panic() {
    // (1) panic! 与不可恢复错误
    // panic用于面对影响应用程序的大错误, 不可恢复错误等
    // 对于这些严重到影响程序运行的错误, 触发 panic 是很好的解决方式.
    // 在 Rust 中触发 panic 有两种方式:
    //  *被动触发(类似于数组溢出, runtime运行时错误等)
    //  *主动调用(当我们认为这个错误影响程序运行并且不可恢复时, 我们手动抛出错误)
    // WARN: 切记!一定是不可恢复的错误, 才调用 panic! 处理.
    // 你总不想系统仅仅因为用户随便传入一个非法参数就panic吧？这很不合理, 所以只有当你不知道该如何处理时, 再去调用 panic!

    // 1. 手动抛出错误(我们可以设置env展示更详细的堆栈信息: RUST_BACKTRACE=1 cargo run)
    panic!("rust panic!")

    // 2. backtrace 栈展开
}
