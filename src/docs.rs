//! 这是docs模块, 用于编写docs的介绍

pub fn _entry() {
    println!("用于介绍注释是怎么使用的.")

    // (1) 代码注释
    // 1. 行注释, 使用 "//". 没什么好说的了
    // 2. 块注释, 使用 " /* ......*/ ", 只需要将注释内容使用 /* */ 进行包裹即可
    // 你会发现 Rust 的代码注释跟其它语言并没有区别, 主要区别其实在于"文档注释"这一块
    /*
       我
       是
       块
       注
       释
    */

    // (2) 文档注释
    // 当查看一个 crates.io 上的包时, 往往需要通过它提供的文档来浏览相关的功能特性、使用方式, 这种文档就是通过文档注释实现的.
    // Rust提供了`cargo doc`的命令, 可以用于把这些文档注释转换成 HTML 网页文件, 最终展示给用户浏览
    // 这样用户就知道这个包是做什么的以及该如何使用
    //
    // 1. 文档行注释
    // 使用 "///" 在代码块上进行文档行注释
    // 文档注释中的代码有几点需要注意:
    // * 文档注释需要位于`lib`类型的包中, 例如 src/lib.rs 中
    // * 文档注释可以使用 markdown语法! 例如`# Examples`的标题, 以及代码块高亮
    // * 被注释的对象需要使用`pub`对外可见, 记住：文档注释是给用户看的, 内部实现细节不应该被暴露出去
    //
    // 2. 文档块注释
    // 使用 "/** */" 在代码块上进行文档块注释(实际上只是为了避免多写几个"///", 看起来也不美观, 社区还是推荐使用文档行注释)
    //
    // 3. 查看文档滴命令`cargo doc`可以生成 HTML 文件, 放入`target/doc`目录下
    // 我们还可以使用 `cargo doc --open`生成了文档后直接打开
    //
    // 4. 常见的文档标题
    // 之前我们见到了在文档注释中该如何使用 Markdown, 其中包括 # Examples 标题. 除了这个标题还有一些常用的,你可以在项目中酌情使用：
    // * Panics: 函数可能会出现的异常状况, 这样调用函数的人就可以提前规避
    // * Errors: 描述可能出现的错误及什么情况会导致错误, 有助于调用者针对不同的错误采取不同的处理方式
    // * Safety: 如果函数使用 unsafe 代码, 那么调用者就需要注意一些使用条件, 以确保 unsafe 代码块的正常工作

    // (3) 包和模块级别的注释(加载package和mod的上方)
    // 除了函数、结构体等 Rust 项的注释, 你还可以给包和模块添加注释. 需要注意的是, 这些注释要添加到包、模块的最上方！
    // 与之前的任何注释一样, 包级别的注释也分为两种:
    // * 行注释 //!
    // * 块注释 /*! ... */

    // (4) 文档测试(Doc Test)
    // 相信读者之前都写过单元测试用例, 其中一个很蛋疼的问题就是: 随着代码的进化, 单元测试用例经常会失效, 不要问为什么 :)
    // rust提供了一种文档测试的方式, 也就是允许我们在注释中编写单元测试用例
    // 注释不仅仅是文档, 还可以作为单元测试的用例运行, 使用 cargo test 运行测试
    //
    // 需要注意的是, 我们可能需要使用类如 "rs::add_one(arg)" 的完整路径来调用函数, 因为测试是在另外一个"独立的线程中"运行的
    //
    // 1. 造成panic的文档测试
    // 文档测试中的用例还可以造成 panic. 如果想要通过这种测试, 我们可以添加 should_panic. 通过 should_panic, 告诉 Rust 我们这个用例会导致 panic, 这样测试用例就能顺利通过
    /*
       // 如何添加`should_panic`呢？ 我们在代码块声明时进行添加:
       ```rust,should_painc
            let xx = oo;
       ```
    */
    //
    // 2. 保留测试, 隐藏文档
    // 在某些时候, 我们希望保留文档测试的功能, 但是又要将某些测试用例的内容从文档中隐藏起来.
    /*
       /// ```
       /// # // 使用#开头的行会在文档中被隐藏起来, 但是依然会在文档测试中运行
       /// # let a = 10;
       /// # println!("a: {}",a);
       /// ```

    */

    // (5) 文档注释中的代码跳转
    // Rust 在文档注释中还提供了一个非常强大的功能, 那就是可以实现对外部项的链接
    //
    // 1. 跳转到标准库
    // '_add'的 [Option] 就是一个链接, 指向了标准库中的 Option 枚举类型, 有两种方式可以进行跳转:
    //  * 在 IDE 中, 使用 Command + 鼠标左键(macOS)
    //  * 在文档中直接点击链接
    //
    // 2. 使用完整路径跳转到指定项
    // 除了跳转到标准库, 你还可以通过指定具体的路径跳转到自己代码或者其它库的指定项
    // 例如添加以下代码:
    // [`crate::a::b::c`]
    //
    // 3. 同名项的跳转
    // 如果遇到同名项, 可以使用标示类型的方式进行跳转
    /*
        /// 跳转到结构体  [`Foo`](struct@Foo)
        pub struct Bar;

        /// 跳转到同名函数 [`Foo`](fn@Foo)
        pub struct Foo {}

        /// 跳转到同名宏 [`foo!`]
        pub fn Foo() {}
    */

    // (6) 文件搜索别名
    // Rust 文档支持搜索功能, 我们可以为自己的类型定义几个别名, 以实现更好的搜索展现
    // 当别名命中时, 搜索结果会被放在第一位
    /*
       // 使用"bar"作为别名, 在搜索时就可以很快速的找到
       #[doc(alias = "bar")]
       pub struct Foo;
    */
}

/// `_add` 返回一个 [`Option`] 类型
///
/// 还可以看看相似的枚举 [`std::result::Result`]
fn _add(x: i32) -> Option<i32> {
    Some(x)
}
