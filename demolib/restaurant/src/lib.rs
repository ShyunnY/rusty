// * 使用 mod 关键字来创建新模块，后面紧跟着模块名称
// * 模块可以嵌套
// * 模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等
// * 所有模块均定义在同一个文件中
mod front_of_house {
    // 我们必须为子模块添加pub进行导出
    pub mod hosting {
        // 我们必须为子模块添加pub进行导出
        pub fn add_to_waitlist() {}

        pub fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {
            // 调用父模块平级的其他mod
            // 由于 hosting 和 serving 属于平级, 并且 serving 是当前的父模块
            // 所以我们可以使用supper进行调用, 本质上就像文件调用系统一样: ../
            super::hosting::seat_at_table();
        }

        fn serve_order() {}

        fn take_payment() {}
    }
}

fn hello_brother() {}

// (1) 模块树
// 在我们上述定义的mod模块中, 彼此嵌套形成了下列的一颗模块树（看起来就像计算机中的文件树组织结构）
// crate
//  └── front_of_house
//      ├── hosting
//      │   ├── add_to_waitlist
//      │   └── seat_at_table
//      └── serving
//          ├── take_order
//          ├── serve_order
//          └── take_payment
//
// 父子模块
// 如果模块 A 包含模块 B, 那么A是B的父模块, B是A的子模块
// 每个文件都有自己的路径, 用户可以通过这些路径使用它们, 在 Rust 中, 我们也通过路径的方式来引用模块

// (2) 用路径引用模块
// 想要调用一个函数, 就需要知道它的路径. 在 Rust 中, 这种路径有两种形式:
// * 绝对路径, 从包根(crate root)开始路径名以包名或者 crate 作为开头
// * 相对路径, 从当前模块开始以 "self, super 或当前模块的标识符" 作为开头
//
// 看看以下的例子
pub fn eat_at_restaurant() {
    // 默认情况下, 当前函数只能看见front_of_house, 因为他们同处一个模块中
    // 如果想调用front_of_house模块内部的东西, 必须现式的添加为其子模块添加pub

    // 使用绝对路径, 以create开头从crate-root开始
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径(当前函数与front_of_house平级)
    front_of_house::hosting::add_to_waitlist();

    // 访问兄弟模块的函数
    hello_brother();
}

//
// 1. 绝对路径引用
// 因为`eat_at_restaurant`和`add_to_waitlist`都定义"在一个crate"中
// 因此在绝对路径引用时, 可以直接以 crate 开头, 然后逐层引用, 每一层之间使用"::"分隔
// 绝对路径的调用, 完全符合了模块树的层级递进. 非常符合直觉, 如果类比文件系统, 就跟使用绝对路径调用可执行程序差不多
// crate::front_of_house::hosting::add_to_waitlist() -> /front_of_house/hosting/add_to_waitlist() 看起来很像文件树模式
//
// 2. 相对路径引用
// 因为`eat_at_restaurant`和`add_to_waitlist`都定义"在一个crate"中
// 我们可以直接使用同级的模块名称进行调用
// 就相当于在同一个父文件夹下, 我们可以通过同级文件名进行调用: front_of_house/hosting/add_to_waitlist()
//
// 3. 选择绝对还是相对?
// 如果只是为了引用到指定模块中的对象, 那么两种都可以. 最终如何选择还是看我们的代码组织结构
// 但是在实际使用时, 需要遵循一个原则: 当代码被挪动位置时,尽量减少引用路径的修改.
// 相信大家都遇到过修改了某处代码, 导致所有路径都要挨个替换, 这显然不是好的路径选择.

// (3) 代码可见性
// Rust 出于安全的考虑, 默认情况下所有的类型都是私有化的，包括函数、方法、结构体、枚举、常量和模块
// 在Rust中, 父模块和父模块的兄弟模块完全无法访问子模块中的私有项, 但是子模块却可以访问父模块、父父..模块的私有项
// "同一个模块内的代码自然不存在私有化" -- 也就是说处于同一模块中的兄弟模块之间是可以访问滴
// Rust 提供了 pub 关键字, 通过它你可以控制模块和模块中指定项的可见性
// 其实我们只要理解了rust中模块的"父子关系", "兄弟关系"即可, 然后将其转换为理解文件目录层级一样理解

// (4) 使用 super 引用模块
// super 代表的是父模块为开始的引用方式, 非常类似于文件系统中的 .. 语法: "../a/b 文件名"
// 如果你确定未来这种层级关系不会改变, 那么 "super::XXOO" 的方式会更稳定.
// 未来就算它们都不在包根了, 依然无需修改引用路径

// (5) 使用 self 引用自身模块
// self 其实就是引用自身模块中的项, 也就是说和我们之前章节的代码类似, 都调用同一模块中的内容
// 换成文件系统中, 其实就是: "./" 的语法一样

// 4. 结构体和枚举的可见性
// 为何要把结构体和枚举的可见性单独拎出来讲呢？因为这两个家伙的成员字段拥有完全不同的可见性:
// * 将结构体设置为 pub, 但它的所有字段依然是私有的(结构体的所有字段都是私有的!!!, 需要让程序猿显示控制导出性)
// * 将枚举设置为 pub, 它的所有字段也将对外可见(枚举一旦pub, 那么剩余的所有字段都是pub的)
// 原因在于:
// (1)枚举和结构体的使用方式不一样.如果枚举的成员对外不可见,那该枚举将一点用都没有.
//    因此枚举成员的可见性自动跟枚举可见性保持一致, 这样可以简化用户的使用.
// (2)而结构体的应用场景比较复杂, 其中的字段也往往部分在 A 处被使用, 部分在 B 处被使用, 因此无法确定成员的可见性.
//    那索性就设置为全部不可见, 将选择权交给程序员

// 测试函数
#[cfg(test)]
mod tests {

    #[test]
    fn multi_file_mod() {
        println!("现在开始执行多文件组织!");

        girls::say();
    }
}
