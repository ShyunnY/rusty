use std::fmt::Debug;

pub fn _entry() {
    println!("hello, rust lifetime");

    // 认识生命周期
    // 生命周期: **简而言之就是引用的有效作用域**. 在大多数时候, 我们无需手动的声明生命周期, 因为编译器可以自动进行推导
    // 用类型来类比下:
    // 1). 就像编译器大部分时候可以自动推导类型 <_> 一样, 编译器大多数时候也可以自动推导生命周期
    // 2). 在多种类型存在时, 编译器往往要求我们手动标明类型 <_>.
    // 3). 当多个生命周期存在,且编译器无法推导出某个引用的生命周期时, 就需要我们"手动标明生命周期"
    //
    // 存在即合理, 那么生命周期的存在又是为了解决什么问题?
    // 1). 防止悬垂引用: 悬垂引用是指引用指向的内存**已经被释放**, 但引用本身仍然存在的情况.
    //     在 Rust 中, 编译器"通过生命周期确保引用不会超出它所引用的数据的生命周期"
    // 2). 明确引用的生命周期: 在某些复杂的情况下, Rust 编译器可能无法自动推断出引用的正确生命周期,
    //     这时需要程序员"显式地指定生命周期". 生命周期注解帮助编译器理解不同引用之间的关系, **确保所有引用在使用时都是有效的**
    //
    // 本质: 其根本其实是讨论 "被借用者和借用者之间的存活时间关系--即被借用者的存活时间必须大于等于借用者, 否则借用者会存在访问非法数据的可能."
    //
    // 这时就回到了开头说的内容: 在存在多个引用时, 编译器有时会无法自动推导生命周期, 此时就需要我们手动去标注
    // 通过 "为参数标注合适的生命周期" 来帮助 -> "编译器进行借用检查的分析"

    // (1) 悬挂指针和生命周期的那点事
    // 生命周期的主要作用是避免悬垂引用, 它会导致程序引用了本不该引用的数据
    // 例如:
    // 在这里point拥有更大的作用域, 或者说活得更久.
    // 如果Rust不阻止该悬垂引用的发生, 那么当 _x 被释放后, point 所引用的值就不再是合法的
    // 如果我们想解决也很简单: 让_x的生命周期大于等于point即可
    let point: &i32 = &1;
    {
        let _x = 5;
        // point = &_x  // point在这里借用了 _x 变量
    } // _x的生命周期到此为止了, 被Drop了.
    println!("point: {:?}", point); // 此时point就是个悬挂指针, 因为他借用的数据已经被清理了

    // (2) 借用检查
    // 为了保证 Rust 的所有权和借用的正确性, Rust 使用了一个借用检查器(Borrow checker), 来检查我们程序的借用正确性
    // 在编译期, Rust 会比较两个变量的生命周期. 结果发现 r 明明拥有生命周期 'a, 但是却引用了一个"小得多"的生命周期 'b
    // 在这种情况下编译器会认为我们的程序存在风险, 因此拒绝运行
    // 如果想要编译通过, 也很简单. 只要 'b 比 'a 大就好. 总之, x 变量只要比 r 活得久, 那么 r 就能随意引用 x 且不会存在危险
    // 一句话概括: 被借用者生命周期大于借用者即可~

    // (3) 函数中的生命周期
    // 假设我们在函数中, 定义其引用类型返回由参数提供, 并且存在多个参数. 此时rust就很迷茫了, 它并不知道引用是取决于哪个引用类型参数
    // 所以无法对此进行生命周期分析(毕竟也不知道是谁的引用). 此时就需要我们进行手动标注生命周期.

    // (4) 生命周期标注语法(生命周期标注并"不会改变任何引用的实际作用域" -- 鲁迅)
    //
    // 一个小总结: 生命周期语法用来将"函数的多个引用参数和返回值的作用域关联到一起(让返回值的生命周期等于所有参数生命周期较小的那一个)"
    // 一旦关联到一起后, Rust 就拥有充分的信息来确保我们的操作是内存安全的
    _lifetime_tag();

    // (5) 结构体中的生命周期
    // 设想一下: 当我们在结构体中将字段的类型设置为引用类型, 那么肯定是引用外部类型对吧?
    // 如果此时外部类型被销毁了呢, 结构体中的引用是不是就变成非法的了?
    // 所以我们需要为结构体中的"每一个引用类型的字段标注上生命周期"
    _lifetime_struct();

    // (6) 生命周期消除
    // 我们其实会发现, 在coding过程中很多时候并不需要我们进行手动标注生命周期
    // 例如以下, 该函数的参数和返回值都是引用类型, 尽管我们没有显式的为其标注生命周期, 编译依然可以通过
    // 这就是使用了 "生命周期消除法"
    // fn get_ref(v: &str) -> &str{
    //    v
    // }
    // 对于 get_ref 函数, 它的返回值是一个引用类型, 那么该引用只有两种情况:
    // * 从参数获取(参数只有一个引用类型, 显而易见返回值的生命周期肯定是等于它的)
    // * 从函数体内部新创建的变量获取(这种情况会导致悬挂指针, rust是不可能让你编译通过滴~)
    //
    // 在开始之前有几点需要注意:
    // * 消除规则不是万能的,若"编译器不能确定某件事是正确"时,会直接判为不正确, 那么你还是需要手动标注生命周期(我们需要站在编译期的角度去看)
    // * 函数或者方法中, `参数的生命周期被称为-输入生命周期`, `返回值的生命周期被称为-输出生命周期`

    // 三条消除规则(rust编译期所遵循的规则)
    // 编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期.
    // 其中第一条规则应用在输入生命周期上, 第二、三条应用在输出生命周期上
    // 1). 每一个引用参数都会获得独自的生命周期(一个引用类型参数就有一个生命周期标注, 两个引用类型参数就有两个生命周期标注)
    //     例如: fn foo<'a>(x: &'a i32),fn bar<'a, 'b>(x: &'a i32, y: &'b i32)
    // 2). 若只有一个输入生命周期(函数参数中只有一个引用类型), 那么该生命周期会被赋给所有的输出生命周期
    //     例如: _demo()函数, 只有一个引用类型参数, 那么所有输出生命周期就等于该输入生命周期
    // 3). 若存在多个输入生命周期, 且其中一个是 &self 或 &mut self, 则 &self 的生命周期被赋给所有的输出生命周期
    //     例如: 存在self, 则代表这是一个方法. 那么rust会希望返回的引用应该和当前self实例一样的生命周期
    //
    // 在第三条规则, 若一个方法它的返回值的生命周期就是跟参数 &self 的不一样怎么办？总不能强迫我返回的值总是和 &self 活得一样久吧？!
    // 问得好, 答案很简单: "手动标注生命周期", 因为这些规则只是编译器发现你没有标注生命周期时默认去使用的
    // `"当你标注生命周期后, 编译器自然会乖乖听你的话"`

    // (7) 方法中的生命周期
    // * 'a: 'b 是生命周期约束语法, 跟泛型约束非常相似, 用于说明 'a 必须比 'b 活得久
    // * 可以把 'a 和 'b 都在同一个地方声明 "<a': b','b>" 或者使用 where 约束 “ <'a,'b> ...... where 'a: 'b ”
    //
    // 实现方法比想象中简单: 加一个"约束"就能暗示编译器, 尽管引用吧! 反正我想引用的内容比我活得久, 爱咋咋地, 我怎么都不会引用到无效的内容!
    //

    // (8) 静态生命周期
    // 在 Rust 中有一个非常特殊的生命周期, 那就是 'static，"拥有该生命周期的引用可以和整个程序活得一样久"
    // 在之前我们学过字符串字面量, 提到过它是被硬编码进 Rust 的二进制文件中, 因此这些字符串变量全部具有 'static 的生命周期：
    // let s: &'static str = "我的命很长嘿嘿嘿";
    //
    // 我们不能无脑的使用 'static 生命周期标注, 'static 约束确实可以解决生命周期编译不通过的问题
    // 但是问题来了: 本来该引用没有活那么久, 但是你非要说它活那么久, 万一引入了潜在的 BUG 怎么办？
    // 遇到因为生命周期导致的编译不通过问题, 首先想的应该是："是否是我们试图创建一个悬垂引用，或者是试图匹配不一致的生命周期"
    // 而不是简单粗暴的用 'static 来解决问题
    //
    // "'static 生命周期标注本身不会改变引用的作用域."
    // 引用的作用域是由它的声明位置和使用位置决定的. 然而当你为引用添加 'static 生命周期标注时,
    // 你是在声明这个引用的生命周期至少与整个程序的生命周期一样长.
    // 这可能会限制你如何使用这个引用, 因为它要求引用指向的数据必须在程序的整个生命周期内都是有效的.
    //
    // 话又说回来,存在即合理.
    // 有时候, 'static 确实可以帮助我们解决非常复杂的生命周期问题甚至是无法被手动解决的生命周期问题
    // 只要你确定: 你的所有引用的生命周期都是正确的, 只是编译器太笨不懂罢了
    //
    // 做一个小总结:
    // * 生命周期 'static 意味着能和程序活得一样久, 例如字符串字面量和特征对象
    // * 实在遇到解决不了的生命周期标注问题, 可以尝试 T: 'static, 有时候它会给你奇迹

    // (9) 一个复杂的例子
    let ret: &str = _longest_and_display("1", "12", "123");
    println!("lifetime is y, ret={ret}");
}

fn _longest_and_display<'a, 'b, T>(x: &'a str, y: &'b str, any: T) -> &'b str
where
    'a: 'b,
    T: Debug,
{
    println!("any: {:?}", any);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 语法: 使用泛型参数, 并且具有trait约束和生命周期
struct _Demo<'a, T>
where
    T: 'a + Debug,
{
    field: &'a T,
}

// 结构体的生命周期语法类似于泛型
struct _Life<'a> {
    part: &'a str,
}

// impl 中必须使用结构体的完整名称, 包括 <'a>, 因为生命周期标注也是结构体类型的一部分！
// 方法签名中, 往往不需要标注生命周期. 得益于生命周期消除的第一和第三规则
impl<'a, 'b> _Life<'a>
where
    'a: 'b,
{
    // 首先应用第一条规则, 给所有引用类型添加一个独立的生命周期
    // 编译器不知道 msg 的生命周期到底多长, 因此它无法简单的给予它生命周期 'a，而是重新声明了一个全新的生命周期 'b
    // 紧接着应用第三条规则, 将&self的生命周期赋值给&str
    // 尽管我们没有给方法标注生命周期, 但是在第一和第三规则的配合下, 编译器依然完美的为我们亮起了绿灯
    fn _equal(&'a self, _msg: &'b str) -> &'a str {
        self.part
    }

    // 在第三条规则下, &str的生命周期等于&self, 如果我希望&str的生命周期等于_msg呢?
    // &self生命周期是 'a ,_msg生命周期是 'b 此时编译器会报错, 因为编译器无法知道 'a 和 'b 的关系.
    //
    // 在这里分为两种情况:
    // * 返回self.part: 因为self的生命周期是'a, 我们让其作为'b的生命周期进行返回, 那么肯定是需要保证'a的生命周期至少和'b一样长
    //   如果 'a 没有 'b 长, 那么在 _msg 的生命周期结束之后, part 的引用可能会指向一个不再有效的内存区域, 这将违反 Rust 的借用规则
    // * 返回_msg: 这就不需要管了, 因为 _msg 本来就是 'b 生命周期的
    // 总之一句话: 我们做的一切都是希望rust编译期能够理解
    fn _no_equal(&'a self, _msg: &'b str) -> &'b str {
        self.part
    }
}

fn _demo(x: &i32, _y: i32) -> (&i32, &i32) {
    (&x, &x)
}

// 该生命周期标注说明, 结构体 Msg 所引用的字符串 str "必须大于等于结构体的寿命!!!"
#[derive(Debug)]
struct Msg<'a> {
    message: &'a str, // 如果不对其进行生命周期标注, 那么rust无法得知此引用是否会变的非法
}

fn _lifetime_struct() {
    // 此时我们可以正常编译, 因为我们确定 str 的生命周期跟 Msg 实例一样
    let str = String::from("hello,lifetime");
    let msg: Msg<'_> = Msg { message: &str };
    println!("msg: {:#?}", msg.message)
}

fn _lifetime_tag() {
    // 名言警句: 标记的生命周期只是为了取悦编译器, 让编译器不要难为我们, 记住了吗？
    // 通过生命周期标注其实就是告诉rust编译期: 别自作聪明了, 听我的就好

    // 1. 语法
    // &i32        // 一个引用
    // &'a i32     // 具有显式生命周期的引用
    // &'a mut i32 // 具有显式生命周期的可变引用
    // 例如: fn useless<'a>(first: &'a i32, second: &'a i32) {}
    // 此处生命周期标注仅仅说明, 这两个参数 first 和 second 至少活得和'a 一样久, 至于到底活多久或者哪个活得更久, 抱歉我们都无法得知
    // 我们只是为了取悦rust, 告诉它罢了
    //
    // 在通过函数签名指定生命周期参数时, 我们并没有改变传入引用或者返回引用的真实生命周期.
    // 而是告诉编译器当不满足此约束条件时, 就拒绝编译通过
    //
    // 生命周期永远只会取"最小"的那个生命周期

    // 举个栗子
    let s1 = String::from("0101");
    let result;
    {
        let s2 = String::from("01010");
        result = _logest_str(&s1, &s2);
        println!("result: {result}"); // 这里可以使用result, 因为其生命周期跟s2一样
    }
    // println!("result: {result}");    // 在此处无法使用result, 因为其生命周期是_logest_str参数中较小的那一个: 也就是s2

    // 2. 深入思考生命周期标注
    // 其实我们回想一下,函数的返回值如果是一个引用类型,那么它的生命周期只会来源于:
    // * 函数参数的生命周期(函数参数)
    // * 函数体中某个新建引用的生命周期(函数栈内变量, 此时就是典型的悬挂指针场景)
}

// 此处的返回值来自于参数, 所以rust编译期需要知道返回值的生命周期是多长
// 该函数签名表明对于某些生命周期 'a: 函数的两个参数都至少跟 'a 活得一样久, 同时函数的返回引用也至少跟 'a 活得一样久
// 实际上这意味着返回值的生命周期与参数生命周期中的"较小值一致", 虽然两个参数的生命周期都是标注了 'a
// 但是实际上这两个参数的真实生命周期可能是不一样的(生命周期 'a 不代表生命周期等于 'a，而是大于等于 'a)
fn _logest_str<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
